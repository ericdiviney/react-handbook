import { TwitterTweetEmbed } from 'react-twitter-embed';

# React Performance & Optimization

Performance in React apps should be thought of in 2 ways: {{ className: 'lead' }}

1. Browser Performance (*Non-React* things)
2. Framework Performance (*React-specific* things)

## Loading vs. Runtime Performance

Loading Performance - This is a measure of how fast the content is loaded when a user visits your webpage. Some specific metrics are First Contentful Paint (FCP), Largest Contentful Paint (LCP), First Input Delay (FID), TTI (Time to Interactive), and maybe a "Speed Index".

Runtime Performance - This is a measure of how "smooth" your application runs and functions after the initial load. Some specific metrics for this might be "frame rate", "CPU", and "Memory Usage".

## Measuring Loading Performance

- [PageSpeed Insights](https://pagespeed.web.dev/)
- [WebPageTest.org](https://webpagetest.org/)
- [Lighthouse](https://developer.chrome.com/docs/lighthouse/overview/)

## Loading Performance Optimization

1. Send the absolute minimum code/media over the network
	- Utilize [GZip compression](https://developer.mozilla.org/en-US/docs/Glossary/GZip_compression) server-side to compress all in-flight HTTP requests
	- Optimize all [images](https://kinsta.com/blog/optimize-images-for-web/) and [videos](https://www.keycdn.com/blog/video-optimization) included in the bundle
		- Lazy load [images](https://web.dev/browser-level-image-lazy-loading/)
	- [Building](https://vitejs.dev/config/build-options.html) and [Minifying](https://vitejs.dev/config/build-options.html#build-minify) all project assets to CSS / JavaScript
	- [Code-Splitting](#) your application
		- [Lazy Loading](https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading)
	- [Server-Side Rendering (SSR)](#) and [Static Site Generation (SSG)](#) can improve the First Contentful Paint and Time to Interactive metrics, as they allow the browser to render the page more quickly (and are accessible by search engines).

## Measuring Runtime Performance

Modern React is pretty fast by default. Unless you're building complex components/features - you don't need to reach for optimization tactics until you notice a component/feature behaving slowly.

The best advice to follow: {{ className: 'lead' }}

1. Don't optimize too soon {{ className: 'lead' }}
2. Know what to measure {{ className: 'lead' }}

In modern React apps, most of the performance issues you'll run into can probably be simplified down to to rendering problems (either too slow, or too much). The visual in the tweet below explains how rendering can cause cascading effects across a large application.

<TwitterTweetEmbed tweetId={'1649711882142461952'} />

Read more from Alex Sidorenko in his series [A Visual Guide to React Rendering](https://alexsidorenko.com/blog/react-render-always-rerenders/).

- [Measuring Performance in Chrome](https://developer.chrome.com/docs/devtools/performance/)
- [Debugging in the Browser](https://javascript.info/debugging-chrome)
- [Devtools Coverage](https://developer.chrome.com/docs/devtools/coverage/) - shows how much of your code is being shipped but then NOT running (while session is recording)
- [How to Detect Slow Renders in React?](https://alexsidorenko.com/blog/react-performance-slow-renders/)
- [How many re-renders are too many?](https://alexsidorenko.com/blog/react-how-many-rerenders/)

## Runtime Performance Optimization

Runtime performance issues usually boil down to two types of issues:

1. Fixing Slow Renders {{ className: 'lead' }}

- Understand that ES6 is [single-threaded](https://javascript.info/event-loop)
- Offload expensive work that shouldn't block rendering to [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)

2. Fixing Re-Renders {{ className: 'lead' }}

- Use [Refs](https://react.dev/learn/referencing-values-with-refs) for state & updates that shouldn't cause re-renders
- Be careful of setting state in an effect or outside of event-handlers / conditions
		
