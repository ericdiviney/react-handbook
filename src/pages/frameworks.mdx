export const description =
  'Explore the React meta-frameworks and build tools that run behind them.'

# Frameworks & Build Tools

Today there are plenty of variants of React, some that will suit your use case better than others. Read below to see the current state of each of these, what they offer, and why you might pick them when starting a new React app.

![ouch hot take](/ouch-hot-take.png)

This debate/conversation is definitely still being played out in the open-source community - but at this point, it is mainly recommended to be using frameworks when building your apps. Some valuable advice when working with these frameworks is **don't fight the frameworks' choices**. If you disagree philosophically enough with React or the framework - just choose another one. Inventing and managing your own internal framework, or bastardizing a meta-framework to fit your needs is only going to cause you headaches and lots of effort.

Read more [from the official react documentation](https://beta.reactjs.org/learn/start-a-new-react-project#building-with-a-full-featured-framework) on their endorsement of framework usage.

## Vanilla React

Everything in the rest of this article builds on top of React. Given today’s options, it is less likely that you should start a React project from scratch. React without a framework might not be a bad choice if:

- The scope of your app is very lightweight and a relatively simple SPA that doesn't need the advantages of server-side rendering. This scope is very unlikely to change anytime soon.
- Your app is not lightweight or straightforward, and your team will diligently manage all dependencies and technical choices you'll likely need to make for the project to succeed (things like routing, data fetching, client vs server rendering, etc.). Note, this is more of a warning than it is a viable option for your project

**Whatever you do, don't start with CRA (Create-React-App)**

- It is outdated (with more issues popping up every day)
- It ignores the advice of picking a framework instead of just React
- The authors [themselves have said](https://github.com/reactjs/reactjs.org/pull/5487#issuecomment-1409720741) they don't intend on adding new features or maintaining it much further
- [Vite](https://vitejs.dev/guide/#scaffolding-your-first-vite-project) is the current recommended alternative

## React Native

For building mobile (iOS and Android) applications.

You can also use a framework like [Expo](https://expo.dev/) to build an application that will run natively on Android, iOS, AND modern web browsers using the same codebase.

## Next.js, Remix, Gatsby

**What these frameworks have in common**

All 3 frameworks lay the foundations of an application/website built with React. Each framework provides some tooling out-of-the-box for you when starting a new project, and this tooling is meant to make your life easier as a developer. If you embrace what each framework offers, taking advantage of the vast react ecosystem will be much easier.

Before you dive in below, you may benefit by watching [this video](https://www.youtube.com/watch?v=bfLFHp7Sbkg) by Ryan Florence explaining the differences in approach from a server and cache perspective of the frameworks below. After you've watched it, you'll be heading into the next section with a strong understanding of SSG (static site generation) vs SSR (server-side rendering), as well as caching strategies that can decrease the load you put on your server while still serving your users dynamic content that will lead to a positive experience.

**Gatsby**

- Best for: static websites with infrequent content updates, fast content-driven websites, SEO-friendly sites
- Not good if you need: dynamically generated pages (search results, user-generated feeds/content, application dashboards, etc.)
- Tutorials
    - [Official Gatsby Documentation](https://www.gatsbyjs.com/docs/tutorial/)

**Next.js**

- Best for: static websites, performant dynamic web apps/websites, SEO-friendly sites
- Not good if you need: absolutely no requirement for server-side react or if your team has opinionated stances on functionality like routing, data fetching, etc.
- Tutorials
    - [Create a Next.js app - Official Next.js Documentation](https://nextjs.org/learn/basics/create-nextjs-app)
    - [Introduction to Next.js 9](https://egghead.io/courses/introduction-to-next-js-9-9c01) - by Xiaoru Li

**Remix**

- Best for: performant dynamic web apps/websites, SEO-friendly websites, progressive web features, BFFE (backend for front end)
- Not good if you need: ??, framework maturity (TODO: honest breakdown of the fallbacks and negatives of Remix)
- Tutorials:
    - [Up and Running with Remix](https://egghead.io/courses/up-and-running-with-remix-b82b6bb6) - Kent C. Dodds
    - [Remix Tutorial Livestream](https://www.youtube.com/watch?v=hsIWJpuxNj0) - Kent C. Dodds
    - [Jokes App Tutorial](https://remix.run/docs/en/v1/tutorials/jokes) - Official Remix Documentation

## Framework Comparison

**Vanilla React vs Meta-Frameworks**

CRA (Create React App) is a [bad](https://github.com/reactjs/reactjs.org/pull/5487#issuecomment-1409720741) starting point and you also probably shouldn't be starting with vanilla React for your next production application. However, if flexibility is one of your highest concerns, that might be a good reason to start with just React alone. Otherwise, you should probably try Next or Remix.

**Gatsby vs Next**

At this point, other than DX (developer experience) - you're pretty much getting the same end result picking between Next.js and Gatsby. With Next being the more flexible option (without sacrificing performance) there aren’t many reasons to recommend Gatsby. Again, you should consider the DX of everyone that will be working on the project, but as far as functionality - Next gets you everything Gatsby does and more. Gatsby does support server-side generated responses at runtime, but in general, Next has better support for this feature. If your project has any potential to grow beyond the current spec/scope - we recommend Next. Traditionally, some arguments favoring Gatsby might have referenced integrating GraphQL easily, or the [plugin library](https://www.gatsbyjs.com/plugins) - Next.js has since [closed](https://www.apollographql.com/blog/apollo-client/next-js/next-js-getting-started/) the GraphQL gap, and it’s likely you’d be able to find plugin alternatives given the vast React ecosystem.

Further reading

- [Gatsby vs Next.js](https://www.gatsbyjs.com/features/jamstack/gatsby-vs-nextjs) - Official Gatsby.js

**Next vs Remix**

Remix is something newer, attempting to take advantage of many current browser standards that can naturally make web applications more accessible and quicker across many devices and network capabilities. That was a jargony way of saying: *Remix really tries to make your app fast out of the box*. It's a bit of an unorthodox way of building a UI for your application needs, but the decisions are intentional. When comparing Remix to Next.js:

- Both use file-system-based routing
- Both take advantage of HTTP caching to deliver results to users as fast as possible
- Both provide built-in mechanisms for data fetching
- Next is the more battle-tested library in production
- Next does not support “nested routes” ([yet](https://nextjs.org/blog/layouts-rfc?ref=hackernoon.com)), which in general lead to better load times for users
- Remix is built on top of standard Web APIs, Next incentivizes a Node.js approach (for now)
- Relying less on node.js means Remix is more portable to non-node environments like Cloudflare Workers or Deno Deploy and also makes it easier to run “on the edge”
- Remix doesn't support SSG (which in a lot of cases is probably fine if your goals are simply to deliver a fast user experience)
- Remix apps will tend to “work” quicker - since their underlying fundamentals are based on web standards (like forms for mutating data). Remix makes it so users don’t have to wait for a large js bundle (04.chunk.js) to finish loading before they can interact with the page
- Remix (in general) encourages you to move your typical client-side state management to the server

Further reading:

- [Remix vs Next.js](https://remix.run/blog/remix-vs-next) - Official Remix Documentation

In any case, each of the 3 frameworks above is supported not only by a fantastic open-source community but also by commercial funding/investment from 3 companies:

- Remix (acquired by Shopify)
- Next.js (from the team behind Vercel)
- Gatsby (acquired by Netlify)

The future of open-source React is looking very bright!

## High-Performance Websites

Some new ideas are floating around to get really performant static websites.

If this fits your use case, you might benefit from looking into [Astro](https://docs.astro.build/en/guides/integrations-guide/react/) or [Qwik](https://qwik.builder.io/integrations/integration/react/), which are easy to integrate from a React perspective.

## Build Tools

[Webpack](https://webpack.js.org/) was the undisputed winner here for a long time. You probably won't get in too much trouble if you use it now (other than sitting around waiting for development builds to finish). TLDR: It works, but it's slow.

But, now Webpack faces competition:

- [Vite](https://vitejs.dev/guide/why.html) - a great modern alternative to Webpack that leverages browsers' native ES modules support for better performance (less code sent to the browser until required). An excellent option for building web apps and websites
- [parcel](https://parceljs.org/) - another modern alternative build tool + development server, if you are developing a library/package this might fit your needs better than Vite
- [esbuild](https://esbuild.github.io/) - a very flexible zero-config solution for large projects with intricate needs. Will probably be able to do what you need, but at the cost of a pretty steep learning curve

Snowpack used to be a great tool, but it is no longer maintained and recommends Vite as an alternative build tool solution. [wmr](https://wmr.dev/) can also be used as a build tool, though it generally has less open-source support and popularity than the options above.

Further reading:

- [Comparing the New Generation of Build Tools](https://css-tricks.com/comparing-the-new-generation-of-build-tools/#h-vite)