export const description = 'React hooks and all their happy little nuances.'

export const sections = [
  { title: 'useState', id: 'use-state' },
  { title: 'useEffect', id: 'use-effect-use-layout-effect' },
  { title: 'Advanced', id: 'advanced-hooks' },
  { title: 'Ready to Use Hooks', id: 'ready-to-use-hooks' },
]

# Hooks

The new React [docs](https://react.dev/reference/react) are great material for understanding hooks and how to use them in your code. The flow diagram below can also help build your mental model around when certain hook actions are "running" during the component lifecycle.

![hook flow chart](https://raw.githubusercontent.com/donavon/hook-flow/master/hook-flow.png)

## `useState`

Common questions:

- [Is updating hook-state synchronous or asynchronous?](https://www.youtube.com/watch?v=RAJD4KpX8LA)
- [How to process multiple state updates to a variable before re-rendering](https://react.dev/learn/queueing-a-series-of-state-updates)

Tips:

- If the initial value for your state is computationally expensive, consider [lazy state initialization](https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates) to ensure it only runs once per component mount
- If you are updating/setting state values profusely throughout your component, you would probably benefit by switching to the [reducer pattern](https://react.dev/reference/react/useReducer) or even defining a [custom hook](https://react.dev/learn/reusing-logic-with-custom-hooks).
- Read the [Common Pitfalls of `useState`](https://profy.dev/article/react-usestate-pitfalls)
- Store as little "state" as possible, [derive](https://kentcdodds.com/blog/dont-sync-state-derive-it) as much as you can on the fly (e.g. if your form has a "first name" and "last name" fields but you also need to display the full name together, just concatenate the two values together, don't try to store this value in it's own "fullName" state variable)
- Avoid state-effect [Ping-Pong](https://twitter.com/asidorenko_/status/1622904907954094080?s=20), just like above, derive your values as part of the render function. Trying to keep too much info in state/hooks is somewhat of an anti-pattern that can get you into trouble.
- Don't try to update one property in an object or one item in an array, instead you should [replace](https://react.dev/reference/react/useState#updating-objects-and-arrays-in-state) the entire object/array with what the new state value should be. If you need an object to persist between renders but that shouldn't cause re-renders when you change that object, you probably need a [ref (`useRef`)](#advanced-hooks)

## `useEffect` / `useLayoutEffect`

Effects are code that run last during the rendering cycle. You may hear that effects actually run AFTER rendering is complete. What matters is that you know effect code runs last, whether you actually consider it part of the rendering phase or it's own step that happens AFTER rendering phase probably doesn't matter.

You might be using effects wrong if:

- You have code in an effect that "resets" all local component state when a prop changes for that component (read [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect#resetting-all-state-when-a-prop-changes))
- Effects are NOT "subscriptions" - try not to think of them as a way to "opt in" or [listen](https://profy.dev/article/react-usestate-pitfalls#listening-to-state-changes-via-useeffect) to changes to specific variables. Thinking this way can lead to pointless re-renders and therefore laggard performance in your apps
- Related to the above point, if you are updating state with setState() **inside** of your effect, you [might be doing something wrong](https://profy.dev/article/react-usestate-pitfalls#updating-state-via-useeffect) (not always, but we find this more true than not). Since effects run last in the render phase, updating state from there will immediately cause your component to re-render

Tips:

- Read Dan Abramov's [Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/) (and then, when you think you understand effects, read it again)
- When effects run
  - `useEffect(() ⇒ {})` - will run after every render of a component
  - `useEffect(() ⇒ {}, [])` - will run only after the first render of a component
  - `useEffect(() ⇒ {}, [deps])` - will run after renders, but only when deps change

## Advanced Hooks

`useRef` 
- `useRef` is very similar to `useState`, except updates to a ref do NOT trigger re-renders.
- It returns an object that has a property called `current` that we can access as we do with objects.

`useMemo`, `useCallback` - memoize values and functions that don't need to be re-declared every single render-cycle. 

`useMemo` 
- Read more about the performance benefits of `useMemo` on our [Performance](/react-performance-optimization) guide
- The fundamental idea with useMemo is that it allows us to "remember" a computed value between renders.
- It takes two arguments: a chunk of work to be performed, wrapped up in a function and a list of dependencies.
- `useMemo` is essentially like a little cache, and the dependencies are the cache invalidation strategy.

`useCallback` 
- Read more about the performance benefits of `useCallback` on our [Performance](/react-performance-optimization) guide
- `useCallback` serves the same purpose as `useMemo`, but it's built specifically for functions.
- We hand it a function directly, and it memoizes that function, threading it between renders.
- It is syntactic sugar. It exists purely to make our lives a bit nicer when trying to memoize callback functions.

`useReducer` 
- We especially recommend this if there are many calls to update state from your component. 
- When to reach for `useReducer` over `useState` is very nuanced, but we tend to relate it to how many values are kept in local state and how often they are updating. As the number of values and number of updates to those values in your component increase, the more likely you should consider `useReducer` instead of plain `useState`.

## Ready to Use Hooks

You can also copy+paste hooks from the websites below into your own projects. If you prefer to keep npm dependencies as light as possible, you could copy over only the ones you need.

- [usehooks.com](https://www.npmjs.com/package/use-hooks)
- [usehooks-ts.com](https://www.npmjs.com/package/usehooks-ts)
